Лабораторная работа №8

1.Постановка задачи:

Цель:
Изучить основы итерационный степенного метода вычисления наибольшего по модулю собственного значения и соответствующего собственного вектора; разработать программу, реализующую основной случай метода.

Задание:
Разработать программу вычисления наибольшего по величине модуля собственного значения (случай вещественного не кратного собственного значения) и соответствующего ему собственного вектора симметричной матрицы.

Для вычислений: 
Матрица A,  а также значения n,k, задающиеся сам-но. 
e=1(номер группы)
n=1500(задаю сам-но из промежутка от 1500 до 2000)
Матрица является симметричной и заполняется по правилу:
недиагональные элементы ai,j, i<j, выбираются случайным образом из диапазона от 0 до –1000; если i>j, то полагается ai,j=aj,i. 

![image](https://github.com/SnkAnn/Num_methods/assets/108490844/5df0780b-8e17-4f9a-aa6c-e246a185e9f6)

В отчете должны быть представлены:
Вывести на печать uk (приближенно это собственный вектор, соответствующий собственному значению λ1) при k=50. 
В формуле λ1≈ ![image](https://github.com/SnkAnn/Num_methods/assets/108490844/d20b8898-bae7-4cfa-873e-45c6a9e3cec7)
 (формула вспомогательная, не для счета) выбирать такое i, для которого достигается ![image](https://github.com/SnkAnn/Num_methods/assets/108490844/cfa11598-efce-4480-8daa-fba174dd390f)
 ). В этом случае справедливо (это уже для счета) ![image](https://github.com/SnkAnn/Num_methods/assets/108490844/385aa937-6fa4-4335-8a89-05b79a1d3eef)

Для вычисления наибольшего по модулю собственного значения использовать также формулу λ1≈ ![image](https://github.com/SnkAnn/Num_methods/assets/108490844/2ee544b2-b585-4f83-b4ef-64bd0d3119f4)
.

Для обоих случаев приближённого вычисления λ1: вывести на печать приближенное λ1 для k=50; вычислить вектор vk+1–λ1uk (это для проверки насколько оказались хороши вычисленные λ1 и uk: вектор vk+1–λ1uk равен вектору невязки Auk–λ1uk); для k=50 вычислить (для обоих случаев) и вывести на печать  ![image](https://github.com/SnkAnn/Num_methods/assets/108490844/68614c49-3a4b-4e8a-b8ff-62ec01a95f3e)
 или ![image](https://github.com/SnkAnn/Num_methods/assets/108490844/04ef655c-07d1-43d7-a32b-c6181b38fcbd)
 .

Решение:
U0=(1,1,1,….,1);

![image](https://github.com/SnkAnn/Num_methods/assets/108490844/a0212d8e-d961-4b91-ae70-0968f411684b)

Найти при 50 итерациях:

![image](https://github.com/SnkAnn/Num_methods/assets/108490844/fabb3711-0c5a-4486-b677-5e1c8a20b055)

![image](https://github.com/SnkAnn/Num_methods/assets/108490844/0725eefd-ae60-4290-a60b-bb16fbe6f02e)

   
2. Входные данные:
n=1500;  
e=1;
k=50;

6.Вывод:
Собственное значение в двух методах его нахождения получаются в общем близкими, так же как и норма оценки. Но норма меньше выходит  у второго варианта вычисления: λ1≈ .
Чтобы было лучше видно как работает этот метод надо использовать гораздо больше итераций, так например при 5000 итерация мы уже будем иметь норму в более привычном нам виде.
